package kubernetes

import (
	"fmt"
	"time"

	"github.com/spf13/viper"
	"github.com/suecodelabs/cnfuzz/src/cmd"
	"github.com/suecodelabs/cnfuzz/src/config"
	"github.com/suecodelabs/cnfuzz/src/kubernetes/job"
	"github.com/suecodelabs/cnfuzz/src/kubernetes/util"
	"github.com/suecodelabs/cnfuzz/src/log"
	"github.com/suecodelabs/cnfuzz/src/model"
	"github.com/suecodelabs/cnfuzz/src/persistence/repository"
	apiv1 "k8s.io/api/core/v1"
	"k8s.io/client-go/kubernetes"
)

// EventHandler that handles Kubernetes events
// if it detects a pod with an image that hasn't been fuzzed yet, it will try to fuzz the pod
type EventHandler struct {
	clientSet    kubernetes.Interface
	repositories *repository.Repositories
	handleFunc   func(clientSet kubernetes.Interface, repositories *repository.Repositories, pod *apiv1.Pod)
}

// NewEventHandler creates a new EventHandler
func NewEventHandler(clientset kubernetes.Interface, repositories *repository.Repositories) *EventHandler {
	return &EventHandler{
		clientSet:    clientset,
		repositories: repositories,
		handleFunc:   HandlePodEvent,
	}
}

// OnAdd handles an add event
func (handler EventHandler) OnAdd(obj any) {
	// Object types
	switch object := obj.(type) {
	case *apiv1.Pod:
		handler.handleFunc(handler.clientSet, handler.repositories, object)
	default:
		return
	}

}

// OnUpdate handles an update event
func (handler EventHandler) OnUpdate(oldObj any, newObj any) {
	switch newObject := newObj.(type) {
	case *apiv1.Pod:
		/* Could check if pod image ID changed
		oldPod := oldObj.(*apiv1.Pod)
		for _, oldStatus := range oldPod.Status.ContainerStatuses {
			for _, newStatus := range newObject.Status.ContainerStatuses {
				log.Printf("New Image ID: %s, Old image ID: %s\n", newStatus.ImageID, oldStatus.ImageID)
			}
		} */
		handler.handleFunc(handler.clientSet, handler.repositories, newObject)
	// case *apiv1.PodTemplate:
	// This could mean an entire different image or maybe just a name change
	// Fuzzer will notice any significant changes through regular Pod events
	default:
		return
	}

}

// OnDelete handles a delete event
func (handler EventHandler) OnDelete(obj any) {
	// We just ignore these completely
	// No point in fuzzing a deleted object
}

// HandlePodEvent method that handles an event for a pod
// it decides if the pod needs to be fuzzed and can start the fuzzing process when the pod is ready
func HandlePodEvent(clientSet kubernetes.Interface, repositories *repository.Repositories, pod *apiv1.Pod) {
	logger := log.L()
	annos := GetAnnotations(&pod.ObjectMeta)
	annos.SetConfigRegister()

	// Skip events generated by internal Kubernetes components
	if util.IsKubernetesEvent(&pod.ObjectMeta) {
		return
	}
	if util.IsFuzzerEvent(&pod.ObjectMeta) {
		return
	}
	if annos.IgnoreMe || (viper.GetBool(cmd.OnlyFuzzMarkedFlag) && !annos.FuzzMe) {
		logger.Debugf("pod %s wants to be ignored, so not fuzzing it", pod.Name)
		return
	}

	if !util.PodExist(clientSet, pod.Namespace, pod.Name) {
		logger.Debugf("ignoring event for pod %s because it doesn't exist", pod.Name)
		return
	}

	// Don't start until the pod is ready
	logger.Debugf("event for pod %s", pod.Name)
	logger.Debugf("waiting until pod is ready ...")
	err := util.WaitForPodReady(clientSet, pod, time.Minute)
	if err != nil {
		logger.Error(fmt.Errorf("failed to wait on pod %s being ready: %w", pod.Name, err).Error())
		return
	}

	_, containsUnfuzzedImages := containsUnfuzzedImages(pod, repositories.ContainerImageRepo)
	if !containsUnfuzzedImages {
		logger.Debugf("pod %s contains no images that havent been fuzzed yet", pod.Name)
		return
	}
	logger.Debug("pod contains unfuzzed images")
	logger.Infof("start fuzzing of %s", pod.Name)

	kConfig := config.CreateSchedulerConfigWPod(pod)
	createdJob, jErr := job.LaunchFuzzJob(clientSet, kConfig)
	if jErr != nil {
		// TODO get this error to the user
		logger.Errorf("error while starting new fuzzing job: %+v", jErr)
	} else {
		logger.Infof("launched fuzzing job %s for pod %s", createdJob.Name, pod.Name)
	}
}

// containsUnfuzzedImages gets images from a Pod and checks inside the repository if any of the images are unknown or haven't been fuzzed earlier
func containsUnfuzzedImages(pod *apiv1.Pod, repo repository.IContainerImageRepository) (allImages []model.ContainerImage, containsUnfuzzedImages bool) {
	logger := log.L()
	// Get all images inside pod
	images, err := model.CreateContainerImagesFromPod(pod)
	if err != nil {
		logger.Errorf("Failed to retrieve image information from pods in service %s\n", pod.Name)
		// Skip the image
		return
	}

	// Check if there are new images
	containsUnfuzzedImages = false
	for _, image := range images {
		// Check if the image is known
		foundImage, found, err := repo.FindContainerImageByName(image.Name)
		if err != nil {
			logger.Errorf("error while getting image from storage: %+v", err)
		} else if !found {
			// The image doesn't exist yet
			containsUnfuzzedImages = true

			// Create it, image fuzz status is still unknown, we will update this later
			err := repo.CreateContainerImage(image)
			if err != nil {
				logger.Errorf("error while saving fuzzed image information to storage: %+v", err)
			} else {
				// Finally, add it to our image collection for the pod that triggered the event
			}

			allImages = append(allImages, image)
		} else { // Image has already been added before
			// Check if there is still an unfuzzed version inside the pod
			for _, version := range foundImage.Versions {
				if version.Status == model.NotFuzzed {
					containsUnfuzzedImages = true
				}
			}
			allImages = append(allImages, foundImage)
		}
	}
	return allImages, containsUnfuzzedImages
}
